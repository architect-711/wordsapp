# ðŸ“– WordsApp Documentation

For more info about particular versions look for the files named similar 
to `vX.X.X.md` in the `/versions` subfolder

<p align="center">
    <!-- ![all-technologies-used](./img/all-techs.avif) -->
    <img src="./img/all-techs.avif"/>
</p>

## ðŸ”Ž Description
This file provides the basic info about the whole project to quickly onboard.
It doesn't teach you how to build a particular release and neither tells you
about its features or bugs.

## Table of contents
In this file you'll find:
1. [Where to find the API config files](#api)
2. [The commits styles](#the-commits-style)
3. [Info about tests](#tests)
4. [Project strcture logic](#project-structure)

<!-- <a name="api"/> -->
## API
The `/api` subfolder contains the `api-docs.json` file. It's auto generated
but the Swagger and represents the OpenAPI definition. So you can easily
import it to the postman. 

## The commits style
Use only the style described in the [conventional commits site](https://www.conventionalcommits.org/en/v1.0.0/#summary)

## Tests
This is the most crucial part of the app. Here, I keep the one simple rule:
"No test - not feature".

**How to write a good test?**

I've tried many approaches but stopped on the one: **each test is independent
and standalone and must leave nothing after it**!!! It must every single time in the beginning save what it need
and at the end clean everything. <u>In some cases you can reject of this pratice, but
make sure it's justified. Because some tests might require the database to be empty!</u>

To reach that the `@AfterAll` and `@BeforeAll` methods exist. They might, for example,
clear the `SecurityContextHolder` for you.

This is why the testing is usually done in the Docker container database

## Project Structure

### Top level folders
```
.
â”œâ”€â”€ build                                       - output build dir, autogenerated
â”‚   â”œâ”€â”€ libs                                    - contains build file
â”‚   â”‚   â””â”€â”€ wordsapp-1.0.0.jar
â”œâ”€â”€ build.gradle                                - dependencies, build configs, Java version etc
â”œâ”€â”€ config                                      - contains configuration files, see dedicated docs
â”œâ”€â”€ docker                                      - profile-specific docker compose files
â”‚   â”œâ”€â”€ docker-compose.dev.yml
â”‚   â”œâ”€â”€ docker-compose.prod.yml
â”‚   â””â”€â”€ docker-compose.test.yml
â”œâ”€â”€ docker-compose.yml                          - main docker compose file
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ docs                                        - documentation
â”‚   â”œâ”€â”€ api
â”‚   â”‚   â””â”€â”€ api-docs.json
â”‚   â”œâ”€â”€ img                                     - app-related images
â”‚   â”‚   â”œâ”€â”€ Architecture.drawio.png
â”‚   â”‚   â”œâ”€â”€ Current architecutre.drawio.png
â”‚   â”‚   â””â”€â”€ Database_schema.drawio.png
â”‚   â”œâ”€â”€ README.md                               - app technical documentation
â”‚   â””â”€â”€ versions                                - documentation for a concrete release
â”‚       â””â”€â”€ v0.0.1.md
â”œâ”€â”€ gradle                                      - gradle internals
â”œâ”€â”€ gradlew
â”œâ”€â”€ gradlew.bat
â”œâ”€â”€ LICENSE
â”œâ”€â”€ logs                                        - autogenerated, docker builds output
â”‚   â””â”€â”€ docker.log
â”œâ”€â”€ README.md
â”œâ”€â”€ scripts                                     - helping scripts
â”‚   â”œâ”€â”€ build-jar.sh
â”‚   â”œâ”€â”€ docker-build.sh
â”‚   â”œâ”€â”€ docker-run.sh
â”‚   â”œâ”€â”€ docker-stop.sh
â”‚   â”œâ”€â”€ run.sh
â”‚   â””â”€â”€ utils.sh
â”œâ”€â”€ settings.gradle
â””â”€â”€ src                                         - the app itself
```

### The app code
The logic is simple: each feature has it's own dedicated directory. Follow the logic:
* It's a controller? - put to the `/controller` folder. 
* It's a service - put to the `/service` folder
* It's a service util? - put to the `/service/utils` folder
* It maps DTOs, POJOs or Entities? - `/model/mapper` folder is for you and etc.
* etc

So the FS should look something like this (this is just an **example**):
```
src/main/java/edu/architect_711/wordsapp/                   - the root of project
â”œâ”€â”€ config                                                  - contains @Configuration's
â”‚   â”œâ”€â”€ OpenAPIConfiguration.java
â”‚   â””â”€â”€ SecurityConfiguration.java
â”œâ”€â”€ controller                                              - controllers
â”‚   â”œâ”€â”€ AccountController.java
â”‚   â”œâ”€â”€ ExceptionController.java
â”œâ”€â”€ exception                                               - cutsom exceptions
â”‚   â””â”€â”€ UnauthorizedGroupModifyAttemptException.java        
â”œâ”€â”€ generator                                               - generators
â”‚   â””â”€â”€ Base64Generator.java
â”œâ”€â”€ model                                                   - DTO's, mappers, @Entities, POJOs
â”‚   â”œâ”€â”€ dto                                                 - DTO
â”‚   â”‚   â”œâ”€â”€ account                                         - DTO domain
â”‚   â”‚   â”‚   â”œâ”€â”€ AccountDto.java
â”‚   â”‚   â”‚   â”œâ”€â”€ AccountLoginRequest.java
â”‚   â”‚   â”œâ”€â”€ group
â”‚   â”‚   â”‚   â”œâ”€â”€ GroupDto.java
â”‚   â”‚   â”‚   â”œâ”€â”€ SaveGroupDto.java
â”‚   â”œâ”€â”€ entity                                              - @Entity's
â”‚   â”‚   â”œâ”€â”€ Account.java
â”‚   â”‚   â”œâ”€â”€ Language.java
â”‚   â””â”€â”€ mapper                                              - mapper
â”‚       â”œâ”€â”€ AccountMapper.java
â”‚       â””â”€â”€ WordMapper.java
â”œâ”€â”€ repository                                              - Database repositories
â”‚   â”œâ”€â”€ AccountRepository.java
â”‚   â””â”€â”€ WordRepository.java
â”œâ”€â”€ security                                                - security-related things
â”‚   â”œâ”€â”€ service                                             - security services
â”‚   â”‚   â””â”€â”€ AccountDetailsService.java
â”‚   â””â”€â”€ utils                                               - security utils
â”‚       â”œâ”€â”€ AuthenticationExtractor.java
â”‚       â””â”€â”€ CheckAccess.java
â”œâ”€â”€ service                                                 - services 
â”‚   â”œâ”€â”€ account                                             - domain of service
â”‚   â”‚   â”œâ”€â”€ AccountService.java                             - interface
â”‚   â”‚   â””â”€â”€ DefaultAccountService.java                      - implementation
â”‚   â”œâ”€â”€ group
â”‚   â”‚   â”œâ”€â”€ DefaultGroupService.java
â”‚   â”‚   â””â”€â”€ GroupService.java
â””â”€â”€ WordsAppApplication.java                                - main file
```

## Important remarks about directories
It's very important to tell about some subdirecotires of the `/docs` folder.
Each command logs errors in the `/logs/docker.log` file since it uses Docker, 
if somthing broke down - visit this file.

### `/config`
The app relies on external configuration, such as the database URL, credentials,
profile etc.
They are passed via the environment variables. So you have to **create this directory
manually** and put these 3 files (unless some profiles you don't use):
* `.env.dev` - for dev config
* `.env.prod` - for prod config
* `.env.test` - for test config

Each of them must conclude at least next variables:
```env
export POSTGRES_USERNAME=
export POSTGRES_PASSWORD=
export POSTGRES_HOST_PORT=

export SPRING_PROFILES_ACTIVE=
export SPRING_DATASOURCE_URL=jdbc:postgresql://<DB_SERVICE>:5432/wordsapp
```
<u>Pay attention, the `scripts/run.sh` overrides `SPRING_DATASOURCE_URL` for 
a session, because it runs app outside of the docker container, but specified
line works only with container-to-container communication</u>

### `/docker`
This folder contains 3 files:
* `docker-compose.dev.yml`
* `docker-compose.prod.yml`
* `docker-compose.test.yml`

They all are responsible for the PostgreSQL database container configuration
for each of the profile. Yes, it might create 3 containers, altough
when using scripts under the `scripts/` folder this never happens.

### `/scripts`
This folder helps a developer to run/build etc the whole app. Of course, you
can avoid them and manually feed the `.env.{profile}` file for your favourite IDE/shell,
manually start required DB containers, manually build a JAR file etc.

Anyway, the list of current possibilities:
1. Make a JAR file: `build-jar.sh`
2. Run app ouside of Docker container (almost like ./gradlew ...): `run.sh`
3. Run app inside of Docker container: `docker-run.sh`
4. Build the app and ready image (for production, it tags it also): `docker-build.sh`
5. Stop running containers: `docker-stop.sh`

The `utils.sh` file contains all often used functions. Pay attention, that some 
scripts contain the `VERSION` variable, it's because some functions override it 
